require "spec_helper"

module RailsConnector::LiquidSupport
  describe ObjFilters do
    before do
      initialize_action_view_and_obj
      @action_view.stub(:cms_path_or_url_for_objs).with(@obj, "path", anything).and_return("/foo/path.bar")
    end

    describe "with ObjDrops" do
      describe "when rendering a url" do
        it "should return the obj's path as generated by the cms_path helper" do
          render_liquid('<object data="{{ obj | url }}"/>').should == '<object data="/foo/path.bar"/>'
        end
      end

      describe "when rendering an anchor tag" do
        it "should use the filter input as the link text" do
          render_liquid('{{ "Click me" | link_to: obj }}').should have_tag("a", "Click me")
        end

        it "should generate a path for the given obj and use it as the link target" do
          render_liquid('{{ "Click me" | link_to: obj }}').should have_tag("a[href='/foo/path.bar']", "Click me")
        end

        it "should handle a field value as input" do
          @obj.stub_attrs!(:title => "Title Spam")
          render_liquid('{{ obj.title | link_to: obj }}').should have_tag("a[href='/foo/path.bar']", "Title Spam")
        end
      end

      describe "when rendering an image tag" do
        it "should use the path to the input obj as image source" do
          @obj.stub(:title => "my title")
          render_liquid('{{ obj | image_tag }}').should have_tag("img[src='/foo/path.bar']")
        end
      end
    end

    describe "with LinkLists / LinkDrops" do
      before do
        Obj.stub(:find).with([23]).and_return([
          @link_dest = Obj.new.stub_attrs!(:id => 23, :title => "Me got zome tytle, actchely!",
              :active? => true, :obj_class => 'Publication')
        ])
        @action_view.stub(:cms_path_or_url_for_objs).with(@link_dest, "path", anything).and_return("/the/path/to/enligh/tenme.nt")
        @obj.stub_attrs!(
          :related_links => RailsConnector::LinkList.new([
            {:title => 'example a', :url => 'http://a.example.net'},
            {:url => 'http://b.example.net'},
            {:destination => 23, :title => "do not click"},
            {:destination => 23}
          ])
        )
      end

      describe "when rendering an url" do
        it "should render urls for external links" do
          render_liquid('<object data="{{ obj.related_links[0] | url }}"/>').should == '<object data="http://a.example.net"/>'
        end

        it "should render urls for internal links" do
          render_liquid('<object data="{{ obj.related_links[2] | url }}"/>').should == '<object data="/the/path/to/enligh/tenme.nt"/>'
        end

        it "should render urls linklists as a short-hand access to the first element" do
          render_liquid('<object data="{{ obj.related_links | url }}"/>').should == '<object data="http://a.example.net"/>'
        end
      end

      describe "when rendering anchor tags" do
        it "should use the url as href" do
          render_liquid('{{ obj.related_links[0] | link_to }}').should have_tag("a[href='http://a.example.net']")
          render_liquid('{{ obj.related_links[3] | link_to }}').should have_tag("a[href='/the/path/to/enligh/tenme.nt']")
        end

        it "should use the link title" do
          render_liquid('{{ obj.related_links[0] | link_to }}').should have_tag('a', 'example a')
          render_liquid('{{ obj.related_links[2] | link_to }}').should have_tag('a', 'do not click')
        end

        it "should use the url as title if no link title is given" do
          render_liquid('{{ obj.related_links[1] | link_to }}').should have_tag('a', 'http://b.example.net')
        end

        it "should use the destination object title if no link title is given" do
          render_liquid('{{ obj.related_links[3] | link_to }}').should have_tag('a', 'Me got zome tytle, actchely!')
        end

        it "should use the filter input as the link text" do
          render_liquid('{{ "Click me" | link_to: obj.related_links[2] }}').should have_tag("a", "Click me")
          render_liquid('{{ "" | link_to: obj.related_links[2] }}').should have_tag("a", "")
        end

        it "should ignore out-of-bound link indices" do
          render_liquid('wonder{{ obj.related_links[5] | link_to }}wall').should == 'wonderwall'
          render_liquid('water{{ "Click me" | link_to: obj.related_links[5] }}loo').should == 'waterloo'
        end

        it "should offer short-hand access to the first element of a linklist" do
          render_liquid('{{ obj.related_links | link_to }}').should have_tag('a', 'example a')
          render_liquid('{{ obj.related_links | link_to }}').should have_tag("a[href='http://a.example.net']")
        end
      end

      describe "when rendering an image tag" do
        before do
          Obj.stub(:find).with([12]).and_return([
            @img = Obj.new.stub_attrs!(:id => 12, :title => "Me got zome tytle, actchely!",
                :active? => true, :obj_class => 'Publication')
          ])
          @action_view.stub(:cms_path_or_url_for_objs).with(@img, "path", anything).and_return("/images/nature/beautiful/sunset78.jpg")
          @obj.stub_attrs!(
            :big_image => RailsConnector::LinkList.new([
              {:destination => 12, :title => "a beautiful sunset"},
              {:url => "http://example.net/sunset.jpg"}
            ])
          )
        end

        it "should use the obj path as img source" do
          render_liquid('{{ obj.big_image[0].destination | image_tag }}').
            should have_tag('img[src="/images/nature/beautiful/sunset78.jpg"]')
        end

        it "should use the link title as alt" do
          render_liquid('{{ obj.big_image[0] | image_tag }}').
            should have_tag('img[alt="a beautiful sunset"]')
        end

        it "should use an alternative text if given" do
          render_liquid('{{ obj.big_image[0].destination | image_tag: "alternative text" }}').
            should have_tag('img[alt="alternative text"]')
        end

        it "should work with shorthand access to the first element of a link list" do
          render_liquid('{{ obj.big_image | image_tag }}').
            should have_tag('img[src="/images/nature/beautiful/sunset78.jpg"]')
          render_liquid('{{ obj.big_image | image_tag }}').
            should have_tag('img[alt="a beautiful sunset"]')
        end

        it "should work with external links" do
          render_liquid('{{ obj.big_image[1] | image_tag }}').
            should have_tag("img[src='http://example.net/sunset.jpg']")
        end

      end
    end

    describe "when escaping html in a liquid filter chain" do
      before do
        initialize_action_view_and_obj
        RailsConnector::Configuration.auto_liquid_editmarkers = false
        @time = Time.now
        @obj.stub_attrs!(:attr => 'You & Me', :create_at => @time)
      end

      after do
        RailsConnector::Configuration.auto_liquid_editmarkers = true
      end
      describe "and the value is not an instance of Time" do
        it "should escape only the value but not html generated by filters" do
          render_liquid('{{ obj.attr | headline: 3 }}').should == '<h3>You &amp; Me</h3>'
        end
      end
      describe "and the value is an instance of Time" do
        it "should escape only the value but not html generated by filters" do
          render_liquid('{{ obj.create_at | headline: 3 }}').should == "<h3>#{@time}</h3>"
        end
      end
    end

    describe "when deciding whether to render an edit marker" do
      before do
        @obj.stub_attrs!(:title => 'Page Title')
        RailsConnector::Configuration.stub(:editor_interface_enabled? => true)
      end

      it "should not modify the original drop object" do
        render_liquid(
          '{% assign title = obj.title %}{{ title | editmarker: false }}{{ title }}'
        ).should =~ /Page Title<span.*>Page Title<\/span>/
      end

      describe "where Configuration detemines that editmarkers should be shown" do
        it "should render an edit marker when called with true" do
          render_liquid('{{ obj.title | editmarker: true }}').should have_tag("span", "Page Title")
        end

        it "should not render an edit marker when called with false" do
          render_liquid('{{ obj.title | editmarker: false }}').should_not have_tag("span", "Page Title")
          render_liquid('{{ obj.title | editmarker: false }}').should == "Page Title"
        end
      end

      describe "where Configuration detemines that editmarkers should not be shown" do
        before do
          RailsConnector::Configuration.auto_liquid_editmarkers = false
        end

        after do
          RailsConnector::Configuration.auto_liquid_editmarkers = true
        end

        it "should render an edit marker when called with true" do
          render_liquid('{{ obj.title | editmarker: true }}').should have_tag("span", "Page Title")
        end

        it "should render an edit marker when called without a parameter" do
          render_liquid('{{ obj.title | editmarker }}').should have_tag("span", "Page Title")
        end

        it "should not render an edit marker when called with false" do
          render_liquid('{{ obj.title | editmarker: false }}').should_not have_tag("span", "Page Title")
          render_liquid('{{ obj.title | editmarker: false }}').should == "Page Title"
        end
      end
    end

    describe "when using liquid's standard filters in combination with values from the cms and edit markers" do
      before do
        RailsConnector::Configuration.stub(:editor_interface_enabled? => true)
        @obj.stub_attrs!(:title => 'buyakacha')
      end

      it "should patch user-defined filters" do
        render_liquid('{{ obj.title | spamify | editmarker: true }}').should have_tag("span", "spam and buyakacha")
      end

      it "should patch the given filter only once" do
        module Foo
          def bar; end
        end

        2.times {FieldValueDropPatcher.patch Foo}

        lambda do
          Foo.infopark_rails_connector_infopark_rails_connector_bar
        end.should raise_error(NoMethodError)
      end

      describe "if the given value is a FieldValueDrop" do
        before do
          RailsConnector::Configuration.auto_liquid_editmarkers = false
          @obj.stub_attrs!(:array => %w(buy cha))
        end

        after do
          RailsConnector::Configuration.auto_liquid_editmarkers = true
        end

        describe "and the filter returns a string" do
          it "should call the filter with drop's value" do
            render_liquid('{{ obj.array | join: "aka" }}').should == 'buyakacha'
          end

          it "should return filter's return value wrapped in a drop" do
            render_liquid(
              '{{ obj.array | join: "aka" | editmarker: true}}'
            ).should have_tag("span", 'buyakacha')
          end


          it "should not modify the original drop object" do
            render_liquid(
              '{% assign title = obj.title %}{{ title | upcase }}{{ title }}'
            ).should == 'BUYAKACHAbuyakacha'
          end
        end
      end

      describe "when the filter doesn't return a string" do
        before do
          RailsConnector::Configuration.auto_liquid_editmarkers = true
        end
        it "should return the drop's value as a string" do
          render_liquid('{{ obj.title | size }}').should have_tag("span","9")
        end
      end

      describe "if the given value is not a FieldValueDrop" do
        it "should call the filter with given value " +
            "and return it's return value" do
          render_liquid('{{ "buyakacha" | truncate: 6 }}').should == 'buy...'
        end
      end

      describe "when the filters additional parameters are FieldValueDrops and editmarkers are on" do
        before(:each) do
          @obj.stub_attrs!(:title => "Rolling Stones")
          RailsConnector::Configuration.auto_liquid_editmarkers = true
        end
        it "should call the filter with the drop's value and not render an edit marker" do
          render_liquid('{{ "The Beatles" | replace: "Beatles", obj.title }}').should == 'The Rolling Stones'
        end
      end
    end
  end
end
